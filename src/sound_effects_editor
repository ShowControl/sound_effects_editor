#!/usr/bin/python3
# -*- coding: utf-8
#
# sound_effects_editor is a program to edit the sound effects played by
# sound_effects_player.

#   Copyright © 2017 by John Sauter
#                      <John_Sauter@systemeyescomputerstore.com>

#   This program is free software: you can redistribute it and/or
#   modify it under the terms of the GNU General Public License as
#   published by the Free Software Foundation, either version 3
#   of the License, or (at your option) any later version.

#   This program is distributed in the hope that it will be
#   useful, but WITHOUT ANY WARRANTY; without even the implied
#   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#   See the GNU General Public License for more details.

#   You should have received a copy of the GNU General Public
#   License along with this program.  If you did not,
#   see <http://www.gnu.org/licenses/>.

#   The author's contact information is as follows:
#     John Sauter
#     System Eyes Computer Store
#     20A Northwest Blvd.  Ste 345
#     Nashua, NH  03063-4066
#     telephone: (603) 424-1188
#     e-mail: John_Sauter@systemeyescomputerstore.com


import sys
import gi
gi.require_version('Gtk', '3.0')
from gi.repository import GLib, Gio, Gtk
import os.path
from lxml import etree
import argparse
import pprint
from io import StringIO, BytesIO

# This would typically be its own file
MENU_XML="""
<?xml version="1.0" encoding="UTF-8"?>
<interface>
  <menu id="app-menu">
    <section>
      <attribute name="label" translatable="yes">Change label</attribute>
      <item>
        <attribute name="action">win.change_label</attribute>
        <attribute name="target">String 1</attribute>
        <attribute name="label" translatable="yes">String 1</attribute>
      </item>
      <item>
        <attribute name="action">win.change_label</attribute>
        <attribute name="target">String 2</attribute>
        <attribute name="label" translatable="yes">String 2</attribute>
      </item>
      <item>
        <attribute name="action">win.change_label</attribute>
        <attribute name="target">String 3</attribute>
        <attribute name="label" translatable="yes">String 3</attribute>
      </item>
    </section>
    <section>
      <item>
        <attribute name="action">win.maximize</attribute>
        <attribute name="label" translatable="yes">Maximize</attribute>
      </item>
    </section>
    <section>
      <item>
        <attribute name="action">app.about</attribute>
        <attribute name="label" translatable="yes">_About</attribute>
      </item>
      <item>
        <attribute name="action">app.quit</attribute>
        <attribute name="label" translatable="yes">_Quit</attribute>
        <attribute name="accel">&lt;Primary&gt;q</attribute>
    </item>
    </section>
  </menu>
</interface>
"""

class AppWindow(Gtk.ApplicationWindow):

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        # This will be in the windows group and have the "win" prefix
        max_action = Gio.SimpleAction.new_stateful("maximize", None,
                                           GLib.Variant.new_boolean(False))
        max_action.connect("change-state", self.on_maximize_toggle)
        self.add_action(max_action)

        # Keep it in sync with the actual state
        self.connect("notify::is-maximized",
                            lambda obj, pspec: max_action.set_state(
                                               GLib.Variant.new_boolean(obj.props.is_maximized)))

        lbl_variant = GLib.Variant.new_string("String 1")
        lbl_action = Gio.SimpleAction.new_stateful("change_label", lbl_variant.get_type(),
                                               lbl_variant)
        lbl_action.connect("change-state", self.on_change_label_state)
        self.add_action(lbl_action)

        self.label = Gtk.Label(label=lbl_variant.get_string(),
                               margin=30)
        self.add(self.label)
        self.label.show()

    def on_change_label_state(self, action, value):
        action.set_state(value)
        self.label.set_text(value.get_string())

    def on_maximize_toggle(self, action, value):
        action.set_state(value)
        if value.get_boolean():
            self.maximize()
        else:
            self.unmaximize()

class Application(Gtk.Application):

    def __init__(self, *args, **kwargs):
        super().__init__(*args, application_id="org.example.myapp",
                         flags=Gio.ApplicationFlags.HANDLES_COMMAND_LINE,
                         **kwargs)
        self.window = None

        self.add_main_option("test", ord("t"), GLib.OptionFlags.NONE,
                             GLib.OptionArg.NONE, "Command line test", None)

    def do_startup(self):
        Gtk.Application.do_startup(self)

        action = Gio.SimpleAction.new("about", None)
        action.connect("activate", self.on_about)
        self.add_action(action)

        action = Gio.SimpleAction.new("quit", None)
        action.connect("activate", self.on_quit)
        self.add_action(action)

        builder = Gtk.Builder.new_from_string(MENU_XML, -1)
        self.set_app_menu(builder.get_object("app-menu"))

    def do_activate(self):
        # We only allow a single window and raise any existing ones
        if not self.window:
            # Windows are associated with the application
            # when the last one is closed the application shuts down
            self.window = AppWindow(application=self, title="Main Window")

        self.window.present()

    def do_command_line(self, command_line):
        options = command_line.get_options_dict()

        if options.contains("test"):
            # This is printed on the main instance
            print("Test argument recieved")

        self.activate()
        return 0

    def on_about(self, action, param):
        about_dialog = Gtk.AboutDialog(transient_for=self.window, modal=True)
        about_dialog.present()

    def on_quit(self, action, param):
        self.quit()

if __name__ == "__main__":

    # Process the command line.
    cl_parser = argparse.ArgumentParser (
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description='Edit sound effects for sound_effects_player',
    epilog='Copyright © 2017 by John Sauter' + '\n' +
        'License GPL3+: GNU GPL version 3 or later; ' + '\n' +
        'see <http://gnu.org/licenses/gpl.html> for the full text' +
        ' of the license.' + '\n' +
        'This is free software: you are free to change' +
        ' and redistribute it. ' + '\n' +
        'There is NO WARRANTY, to the extent permitted by law. ' +
        '\n' + '\n'
        'The optional input file is the ShowControl project file.')
    cl_parser.add_argument ('input_file', nargs='?',
                            help='the ShowControl project file')
    cl_parser.add_argument ('--version', action='version',
                            version='sound_effects_editor 0.1 2017-12-18',
                            help='print the version number and exit')
    arguments = cl_parser.parse_args ()
    arguments = vars(arguments)
    commandline_file_name = ""
    if (arguments ['input_file'] != None):
        commandline_file_name = arguments ['input_file']

    # Read the configuration file.  Create it if it doesn't exist.
    config_path = os.path.join (GLib.get_user_config_dir(), "ShowControl",
                                "ShowControl_config.xml")
    os.makedirs (os.path.dirname (config_path), exist_ok=True)
    xml_parser = etree.XMLParser (remove_blank_text=True)
    try:
        config_tree = etree.parse (config_path, xml_parser)
    except OSError:
        # The configuration file does not exist.  Assume default values.
        # We will write it later.
        default_config = \
                         '<show_control>\n' + \
                         '<configuration>\n' + \
                         '<version>1.0</version>\n' + \
                         '<project>\n' + \
                         '<folder> </folder>\n' + \
                         '<file> </file>\n' + \
                         '</project>\n' + \
                         '<prefs>\n' + \
                         '<component id="sound_effects"/>\n' + \
                         '</prefs>\n' + \
                         '</configuration>\n' + \
                         '</show_control>\n'
        config_tree = etree.parse (StringIO(default_config), xml_parser)
    
    config_root = config_tree.getroot()
    if (config_root.tag != "show_control"):
        print ("Not a ShowControl XML file.")
    child = config_root.find("configuration");
    if (child.tag != "configuration"):
        print ("Not a configuration file")
    version = child.find ("version")
    if (version.tag != "version"):
        print ("Version missing")
    version_major, separator, version_minor = version.text.rpartition(".")
    if (version_major != "1"):
        print ("Version wrong: ", version.text)
    project = child.find ("project")
    project_file_name = project.find ("file").text
    if (project_file_name == None):
        project_file_name = ""
    project_folder_name = project.find ("folder").text
    if (project_folder_name == None):
        project_folder_name = ""
    project_path = os.path.join (project_folder_name, project_file_name)
    if (commandline_file_name != ""):
        project_path = os.path.abspath (commandline_file_name)
        project_folder_name = os.path.dirname (project_path)
        project_file_name = os.path.basename (project_path)
        project.find ("file").text = project_file_name
        project.find ("folder").text = project_folder_name
        config_tree.write (config_path, encoding='UTF-8',
                           pretty_print=True, xml_declaration=True)

    try:
        project_tree = etree.parse (project_path, xml_parser)
    except OSError as err:
        print (str(err));
    else:
        project_root = project_tree.getroot()
        print ("top: ", project_root.tag)
        for child in project_root:
            print ("child: ", child.tag)
            for grandchild in child:
                print ("grandchild: ", grandchild.tag)
    app = Application()
    app.run(sys.argv)
