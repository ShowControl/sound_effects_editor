#!/usr/bin/python3
# -*- coding: utf-8
#
# sound_effects_editor is a program to edit the sound effects played by
# sound_effects_player.

#   Copyright © 2017 by John Sauter
#                      <John_Sauter@systemeyescomputerstore.com>

#   This program is free software: you can redistribute it and/or
#   modify it under the terms of the GNU General Public License as
#   published by the Free Software Foundation, either version 3
#   of the License, or (at your option) any later version.

#   This program is distributed in the hope that it will be
#   useful, but WITHOUT ANY WARRANTY; without even the implied
#   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#   See the GNU General Public License for more details.

#   You should have received a copy of the GNU General Public
#   License along with this program.  If you did not,
#   see <http://www.gnu.org/licenses/>.

#   The author's contact information is as follows:
#     John Sauter
#     System Eyes Computer Store
#     20A Northwest Blvd.  Ste 345
#     Nashua, NH  03063-4066
#     telephone: (603) 424-1188
#     e-mail: John_Sauter@systemeyescomputerstore.com


import sys
import gi
gi.require_version('Gtk', '3.0')
from gi.repository import GLib, Gio, Gtk
import os.path
from lxml import etree
import argparse
import pprint
from io import StringIO, BytesIO

# This would typically be its own file
MENU_XML="""
<?xml version="1.0" encoding="UTF-8"?>
<interface>
  <menu id="app-menu">
    <section>
      <attribute name="label" translatable="yes">Change label</attribute>
      <item>
        <attribute name="action">win.change_label</attribute>
        <attribute name="target">String 1</attribute>
        <attribute name="label" translatable="yes">String 1</attribute>
      </item>
      <item>
        <attribute name="action">win.change_label</attribute>
        <attribute name="target">String 2</attribute>
        <attribute name="label" translatable="yes">String 2</attribute>
      </item>
      <item>
        <attribute name="action">win.change_label</attribute>
        <attribute name="target">String 3</attribute>
        <attribute name="label" translatable="yes">String 3</attribute>
      </item>
    </section>
    <section>
      <item>
        <attribute name="action">win.maximize</attribute>
        <attribute name="label" translatable="yes">Maximize</attribute>
      </item>
    </section>
    <section>
      <item>
        <attribute name="action">app.about</attribute>
        <attribute name="label" translatable="yes">_About</attribute>
      </item>
      <item>
        <attribute name="action">app.quit</attribute>
        <attribute name="label" translatable="yes">_Quit</attribute>
        <attribute name="accel">&lt;Primary&gt;q</attribute>
    </item>
    </section>
  </menu>
</interface>
"""

class AppWindow(Gtk.ApplicationWindow):

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        # This will be in the windows group and have the "win" prefix
        max_action = Gio.SimpleAction.new_stateful("maximize", None,
                                           GLib.Variant.new_boolean(False))
        max_action.connect("change-state", self.on_maximize_toggle)
        self.add_action(max_action)

        # Keep it in sync with the actual state
        self.connect("notify::is-maximized",
                            lambda obj, pspec: max_action.set_state(
                                               GLib.Variant.new_boolean(obj.props.is_maximized)))

        lbl_variant = GLib.Variant.new_string("String 1")
        lbl_action = Gio.SimpleAction.new_stateful("change_label", lbl_variant.get_type(),
                                               lbl_variant)
        lbl_action.connect("change-state", self.on_change_label_state)
        self.add_action(lbl_action)

        self.label = Gtk.Label(label=lbl_variant.get_string(),
                               margin=30)
        self.add(self.label)
        self.label.show()

    def on_change_label_state(self, action, value):
        action.set_state(value)
        self.label.set_text(value.get_string())

    def on_maximize_toggle(self, action, value):
        action.set_state(value)
        if value.get_boolean():
            self.maximize()
        else:
            self.unmaximize()

class Application(Gtk.Application):

    def __init__(self, *args, **kwargs):
        super().__init__(*args, application_id="org.example.myapp",
                         flags=Gio.ApplicationFlags.HANDLES_COMMAND_LINE,
                         **kwargs)
        self.window = None

        self.add_main_option("test", ord("t"), GLib.OptionFlags.NONE,
                             GLib.OptionArg.NONE, "Command line test", None)

    def do_startup(self):
        Gtk.Application.do_startup(self)

        action = Gio.SimpleAction.new("about", None)
        action.connect("activate", self.on_about)
        self.add_action(action)

        action = Gio.SimpleAction.new("quit", None)
        action.connect("activate", self.on_quit)
        self.add_action(action)

        builder = Gtk.Builder.new_from_string(MENU_XML, -1)
        self.set_app_menu(builder.get_object("app-menu"))

    def do_activate(self):
        # We only allow a single window and raise any existing ones
        if not self.window:
            # Windows are associated with the application
            # when the last one is closed the application shuts down
            self.window = AppWindow(application=self, title="Main Window")

        self.window.present()

    def do_command_line(self, command_line):
        options = command_line.get_options_dict()

        if options.contains("test"):
            # This is printed on the main instance
            print("Test argument recieved")

        self.activate()
        return 0

    def on_about(self, action, param):
        about_dialog = Gtk.AboutDialog(transient_for=self.window, modal=True)
        about_dialog.present()

    def on_quit(self, action, param):
        self.quit()

# Subroutine to parse a ShowControl sounds description.
def parse_sounds (sounds_path, sounds_child, xml_parser):
    for sound in sounds_child.iter ("sound"):
        name = sound.find ("name")
        print ("Sound name: " + name.text)
    return

# Subroutine to parse a ShowControl sound sequence description.
def parse_sound_sequence (sound_sequence_path, sound_sequence_child,
                          xml_parser):
    for sound_sequence_item in sound_sequence_child.iter ("sequence_item"):
        name = sound_sequence_item.find ("name")
        print ("Sound sequence item name: " + name.text)
    return

# Subroutine to parse a ShowControl equipment description.
# We extract the sound effects.
def parse_equipment (equipment_path, equipment_child, xml_parser):
    # Go through the programs, picking out the sound_effects program.
    for program in equipment_child.iter ("program"):
        if (program.get ("id") == "sound_effects"):
            # Within the sound_effects program we care about the sounds
            # and the sound sequence.
            for sounds in program.iter ("sounds"):
                parse_sounds (equipment_path, sounds, xml_parser)
                # Handle information in a separate file.
                sounds_href = sounds.get ("href")
                if (sounds_href != None):
                    # Read the sounds file.
                    sounds_path = os.path.join (
                        os.path.dirname (equipment_path),
                        sounds_href)
                    try:
                        sounds_tree = etree.parse (sounds_path, xml_parser)
                    except OSError as err:
                        print (str(err))
                        return
                    # Validate the sounds file.
                    sounds_root = sounds_tree.getroot()
                    if (sounds_root.tag != "show_control"):
                        print ("Sounds file is not a ShowControl XML file.")
                        return
                    child = sounds_root.find ("sounds")
                    if (child.tag != "sounds"):
                        print ("Sounds file is not a sounds file.")
                        return
                    version = child.find ("version")
                    if (version.tag != "version"):
                        print ("Version missing from sounds file.")
                        return
                    version_major, separator, version_minor = \
                                                    version.text.rpartition(".")
                    if (version_major != "1"):
                        print ("Version wrong in sounds file: " + version.text)
                        return
                    
                    # Parse the sounds.
                    parse_sounds (sounds_path, child, xml_parser)

            for sound_sequence in program.iter ("sound_sequence"):
                parse_sound_sequence (equipment_path, sound_sequence,
                                      xml_parser)
                # Handle information in a separate file.
                sound_sequence_href = sound_sequence.get ("href")
                if (sound_sequence_href != None):
                    # Read the sound sequence file.
                    sound_sequence_path = os.path.join (
                        os.path.dirname (equipment_path),
                        sound_sequence_href)
                    try:
                        sound_sequence_tree = etree.parse (
                            sound_sequence_path, xml_parser)
                    except OSError as err:
                        print (str(err))
                        return
                    # Validate the sound sequence file.
                    sound_sequence_root = sound_sequence_tree.getroot()
                    if (sound_sequence_root.tag != "show_control"):
                        print ("Sound sequence file is not " +
                               "a ShowControl XML file.")
                        return
                    child = sound_sequence_root.find ("sound_sequence")
                    if (child.tag != "sound_sequence"):
                        print ("Sound sequence file is not " +
                               "a sound sequence file.")
                        return
                    version = child.find ("version")
                    if (version.tag != "version"):
                        print ("Version missing from sound sequence file.")
                        return
                    version_major, separator, version_minor = \
                                                    version.text.rpartition(".")
                    if (version_major != "1"):
                        print ("Version wrong in sound sequence file: " +
                               version.text)
                        return
                    
                    # Parse the sound sequence.
                    parse_sound_sequence (sound_sequence_path, child,
                                          xml_parser)
    return
    
# Subroutine to parse a ShowControl project description.
def parse_project (project_path, project_child, xml_parser):    
    # We only care about the equipment, but it may be both here
    # and in separate files.
    for equipment in project_child.iter ("equipment"):
        parse_equipment (project_path, equipment, xml_parser)
        # Handle any information in separate files.
        equipment_href = equipment.get("href")
        if (equipment_href != None):
            equipment_path = os.path.join (os.path.dirname (project_path),
                                           equipment_href)
            try:
                equipment_tree = etree.parse (equipment_path, xml_parser)
            except OSError as err:
                print (str(err))
                return
            # Validate the equipment file.
            equipment_root = equipment_tree.getroot()
            if (equipment_root.tag != "show_control"):
                print ("Equipment file is not a ShowControl XML file.")
                return
            child = equipment_root.find ("equipment")
            if (child.tag != "equipment"):
                print ("Equipment file is not an equipment file.")
                return
            version = child.find ("version")
            if (version.tag != "version"):
                print ("Version missing from equipment file.")
                return
            version_major, separator, version_minor = \
                                                    version.text.rpartition(".")
            if (version_major != "1"):
                print ("Version wrong in equipment file: " + version.text)
                return
            # Parse the equipment description.
            parse_equipment (equipment_path, child, xml_parser)
    return
    
if __name__ == "__main__":

    # Process the command line.
    cl_parser = argparse.ArgumentParser (
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description='Edit sound effects for sound_effects_player',
    epilog='Copyright © 2017 by John Sauter' + '\n' +
        'License GPL3+: GNU GPL version 3 or later; ' + '\n' +
        'see <http://gnu.org/licenses/gpl.html> for the full text' +
        ' of the license.' + '\n' +
        'This is free software: you are free to change' +
        ' and redistribute it. ' + '\n' +
        'There is NO WARRANTY, to the extent permitted by law. ' +
        '\n' + '\n'
        'The optional input file is the ShowControl project file.')
    cl_parser.add_argument ('input_file', nargs='?',
                            help='the ShowControl project file')
    cl_parser.add_argument ('--version', action='version',
                            version='sound_effects_editor 0.1 2017-12-24',
                            help='print the version number and exit')
    arguments = cl_parser.parse_args ()
    arguments = vars(arguments)
    commandline_file_name = ""
    if (arguments ['input_file'] != None):
        commandline_file_name = arguments ['input_file']

    # Read the configuration file.  Create it if it doesn't exist.
    config_path = os.path.join (GLib.get_user_config_dir(), "ShowControl",
                                "ShowControl_config.xml")
    os.makedirs (os.path.dirname (config_path), exist_ok=True)
    xml_parser = etree.XMLParser (remove_blank_text=True)
    try:
        config_tree = etree.parse (config_path, xml_parser)
    except OSError:
        # The configuration file does not exist.  Assume default values.
        # We will write it later.
        default_config = \
                         '<show_control>\n' + \
                         '<configuration>\n' + \
                         '<version>1.0</version>\n' + \
                         '<project>\n' + \
                         '<folder> </folder>\n' + \
                         '<file> </file>\n' + \
                         '</project>\n' + \
                         '<prefs>\n' + \
                         '<component id="sound_effects"/>\n' + \
                         '</prefs>\n' + \
                         '</configuration>\n' + \
                         '</show_control>\n'
        config_tree = etree.parse (StringIO(default_config), xml_parser)

    # Validate the configuration file.
    config_root = config_tree.getroot()
    if (config_root.tag != "show_control"):
        print ("Configuration file is not a ShowControl XML file.")
    child = config_root.find("configuration")
    if (child.tag != "configuration"):
        print ("Configuration file is not a configuration file")
    version = child.find ("version")
    if (version.tag != "version"):
        print ("Version missing from configuration file")
    version_major, separator, version_minor = version.text.rpartition(".")
    if (version_major != "1"):
        print ("Version wrong in confuguration file: " + version.text)

    # Extract the default project file name from the configuration file.
    project = child.find ("project")
    project_file_name = project.find ("file").text
    if (project_file_name == None):
        project_file_name = ""
    project_folder_name = project.find ("folder").text
    if (project_folder_name == None):
        project_folder_name = ""
    project_path = os.path.join (project_folder_name, project_file_name)

    # If the project file is specified on the command line, use it instead
    # and update the configuration file.
    if (commandline_file_name != ""):
        project_path = os.path.abspath (commandline_file_name)
        project_folder_name = os.path.dirname (project_path)
        project_file_name = os.path.basename (project_path)
        project.find ("file").text = project_file_name
        project.find ("folder").text = project_folder_name
        config_tree.write (config_path, encoding='UTF-8',
                           pretty_print=True, xml_declaration=True)

    # Read the project file.
    try:
        project_tree = etree.parse (project_path, xml_parser)
    except OSError as err:
        print (str(err))
    # Validate the project file.
    project_root = project_tree.getroot()
    if (project_root.tag != "show_control"):
        print ("Project file is not a ShowControl XML file.")

    child = project_root.find ("project")
    if (child.tag != "project"):
        print ("Project file is not a project file.")

    version = child.find ("version")
    if (version.tag != "version"):
        print ("Version missing from project file.")

    version_major, separator, version_minor = version.text.rpartition(".")
    if (version_major != "1"):
        print ("Version wrong in project file: " + version.text)

    # Parse the project.
    parse_project (project_path, child, xml_parser)

    # Run the application.
    app = Application()
    app.run(sys.argv)
